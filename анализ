import torch
import torch.nn as nn
from torchvision import models, transforms
from PIL import Image
import cv2
import numpy as np
import os
import glob
import json
from datetime import datetime
import warnings

warnings.filterwarnings('ignore')

class ModelManager:
    def __init__(self, models_dir="models"):
        self.models_dir = models_dir
        os.makedirs(models_dir, exist_ok=True)

    def get_available_models(self):
        models_list = []

        if not os.path.exists(self.models_dir):
            return models_list

        for file in os.listdir(self.models_dir):
            if file.endswith('.pth'):
                model_path = os.path.join(self.models_dir, file)
                json_path = model_path.replace('.pth', '.json')

                model_info = {
                    'name': file.replace('.pth', ''),
                    'path': model_path,
                    'json_path': json_path,
                    'metadata': None
                }

                if os.path.exists(json_path):
                    try:
                        with open(json_path, 'r') as f:
                            model_info['metadata'] = json.load(f)
                    except:
                        model_info['metadata'] = None

                models_list.append(model_info)

        return models_list

    def get_best_model(self):
        models_list = self.get_available_models()

        if not models_list:
            print("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π!")
            return None

        valid_models = []
        for model in models_list:
            if model['metadata'] and 'accuracy' in model['metadata']:
                valid_models.append(model)

        if not valid_models:
            print("‚ö†Ô∏è  –ù–µ—Ç –º–æ–¥–µ–ª–µ–π —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Ç–æ—á–Ω–æ—Å—Ç–∏. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø–æ—Å–ª–µ–¥–Ω—è—è –º–æ–¥–µ–ª—å.")
            return models_list[0]

        valid_models.sort(key=lambda x: x['metadata']['accuracy'], reverse=True)

        return valid_models[0]

    def select_model_interactive(self):
        models_list = self.get_available_models()

        if not models_list:
            print("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π –≤ –ø–∞–ø–∫–µ 'models/'")
            print("üí° –°–Ω–∞—á–∞–ª–∞ –æ–±—É—á–∏—Ç–µ –º–æ–¥–µ–ª—å —Å –ø–æ–º–æ—â—å—é –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Å–∫—Ä–∏–ø—Ç–∞")
            return None

        print("\nüìã –î–û–°–¢–£–ü–ù–´–ï –ú–û–î–ï–õ–ò:")
        print("=" * 60)

        for i, model in enumerate(models_list, 1):
            if model['metadata']:
                acc = model['metadata'].get('accuracy', 0)
                date = model['metadata'].get('date', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')
                data_size = model['metadata'].get('data_size', 0)
                print(f"{i}. üè∑Ô∏è  {model['name']}")
                print(f"   üìÖ {date}")
                print(f"   üéØ –¢–æ—á–Ω–æ—Å—Ç—å: {acc:.2f}%")
                print(f"   üìä –î–∞–Ω–Ω—ã—Ö: {data_size} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π")
            else:
                print(f"{i}. üè∑Ô∏è  {model['name']} (–±–µ–∑ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö)")
            print("   " + "-" * 40)

        print("\n0. üèÜ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª—É—á—à—É—é –º–æ–¥–µ–ª—å (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—ã–±–æ—Ä)")

        try:
            choice = input("\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å (0 –¥–ª—è –ª—É—á—à–µ–π, –Ω–æ–º–µ—Ä –º–æ–¥–µ–ª–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞): ").strip()

            if choice == '0' or choice.lower() == '–ª—É—á—à–∞—è':
                best_model = self.get_best_model()
                if best_model:
                    print(f"\n‚úÖ –í—ã–±—Ä–∞–Ω–∞ –ª—É—á—à–∞—è –º–æ–¥–µ–ª—å: {best_model['name']}")
                    if best_model['metadata']:
                        print(f"   üéØ –¢–æ—á–Ω–æ—Å—Ç—å: {best_model['metadata']['accuracy']:.2f}%")
                    return best_model
                else:
                    print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–±—Ä–∞—Ç—å –ª—É—á—à—É—é –º–æ–¥–µ–ª—å")
                    return None

            choice_idx = int(choice) - 1
            if 0 <= choice_idx < len(models_list):
                selected = models_list[choice_idx]
                print(f"\n‚úÖ –í—ã–±—Ä–∞–Ω–∞ –º–æ–¥–µ–ª—å: {selected['name']}")
                if selected['metadata']:
                    print(f"   üéØ –¢–æ—á–Ω–æ—Å—Ç—å: {selected['metadata']['accuracy']:.2f}%")
                return selected
            else:
                print("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä!")
                return None

        except ValueError:
            print("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ!")
            return None

class AdvancedDefectClassifier:
    def __init__(self, model_path, device=None):
        if device is None:
            self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        else:
            self.device = device

        print(f"üöÄ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {self.device}")

        self.model_info = self._load_model_info(model_path)

        if self.model_info and 'classes' in self.model_info:
            self.class_names = self.model_info['classes']
        else:
            self.class_names = ['crack', 'corrosion', 'normal']

        print(f"üìä –ö–ª–∞—Å—Å—ã –º–æ–¥–µ–ª–∏: {', '.join(self.class_names)}")

        self.model = self._create_model_architecture()

        try:
            self.model.load_state_dict(torch.load(model_path, map_location=self.device, weights_only=True))
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏: {e}")
            try:
                self.model.load_state_dict(torch.load(model_path, map_location=self.device))
                print("‚úÖ –ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –±–µ–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ weights_only")
            except Exception as e2:
                print(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏: {e2}")
                raise

        self.model.to(self.device)
        self.model.eval()

        self.transform = self._create_transforms()

        print("‚úÖ –ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏ –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ!")
        if self.model_info and 'accuracy' in self.model_info:
            print(f"üéØ –¢–æ—á–Ω–æ—Å—Ç—å –º–æ–¥–µ–ª–∏: {self.model_info['accuracy']:.2f}%")

    def _load_model_info(self, model_path):
        json_path = model_path.replace('.pth', '.json')
        if os.path.exists(json_path):
            try:
                with open(json_path, 'r') as f:
                    return json.load(f)
            except Exception as e:
                print(f"‚ö†Ô∏è  –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö: {e}")
                return None
        else:
            print("‚ö†Ô∏è  –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –º–æ–¥–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")
            return None

    def _create_model_architecture(self):
        model = models.efficientnet_b3(weights=None)

        num_features = model.classifier[1].in_features

        num_classes = len(self.class_names)
        print(f"üìä –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Å–æ–≤: {num_classes}")

        model.classifier = nn.Sequential(
            nn.Dropout(0.4),
            nn.Linear(num_features, 512),
            nn.ReLU(),
            nn.BatchNorm1d(512),
            nn.Dropout(0.3),
            nn.Linear(512, 256),
            nn.ReLU(),
            nn.BatchNorm1d(256),
            nn.Dropout(0.2),
            nn.Linear(256, num_classes)
        )

        return model

    def _create_transforms(self):
        return transforms.Compose([
            transforms.Resize((256, 256)),
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                 std=[0.229, 0.224, 0.225])
        ])

    def predict_image(self, image_path, confidence_threshold=0.6):
        try:
            if not os.path.exists(image_path):
                print(f"‚ùå –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {image_path}")
                return None, 0, None

            image = Image.open(image_path).convert('RGB')

            original_image = cv2.imread(image_path)

            input_tensor = self.transform(image).unsqueeze(0).to(self.device)

            with torch.no_grad():
                outputs = self.model(input_tensor)
                probabilities = torch.nn.functional.softmax(outputs, dim=1)
                confidence, predicted = torch.max(probabilities, 1)

            if predicted.item() < len(self.class_names):
                predicted_class = self.class_names[predicted.item()]
            else:
                print(f"‚ö†Ô∏è  –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω—ã–π –∏–Ω–¥–µ–∫—Å {predicted.item()} –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –ø—Ä–µ–¥–µ–ª—ã —Å–ø–∏—Å–∫–∞ –∫–ª–∞—Å—Å–æ–≤")
                predicted_class = "unknown"

            confidence_value = confidence.item()

            if confidence_value < confidence_threshold:
                predicted_class = "uncertain"

            return predicted_class, confidence_value, original_image

        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ {image_path}: {e}")
            import traceback
            traceback.print_exc()
            return None, 0, None

    def predict_batch(self, image_paths, confidence_threshold=0.6):
        results = []

        for i, image_path in enumerate(image_paths, 1):
            print(f"[{i}/{len(image_paths)}] –ê–Ω–∞–ª–∏–∑: {os.path.basename(image_path)}")

            result, confidence, _ = self.predict_image(image_path, confidence_threshold)

            if result:
                results.append({
                    'file': os.path.basename(image_path),
                    'path': image_path,
                    'result': result,
                    'confidence': confidence,
                    'status': self._get_status_emoji(result)
                })
                print(f"    –†–µ–∑—É–ª—å—Ç–∞—Ç: {result} ({confidence:.2%})")

        return results

    def _get_status_emoji(self, result):
        if result == 'crack':
            return 'üö®'
        elif result == 'corrosion':
            return '‚ö†Ô∏è'
        elif result == 'normal':
            return '‚úÖ'
        elif result == 'uncertain':
            return '‚ùì'
        else:
            return '‚ùì'

def display_recommendations(result, confidence):
    print("\nüí° –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò:")
    if result == 'crack':
        if confidence > 0.8:
            print("üö® –í–´–°–û–ö–ò–ô –†–ò–°–ö! –¢—Ä–µ–±—É–µ—Ç—Å—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω—ã–π –æ—Å–º–æ—Ç—Ä —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–∞.")
        else:
            print("‚ö†Ô∏è  –í–æ–∑–º–æ–∂–Ω–∞—è —Ç—Ä–µ—â–∏–Ω–∞. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞.")
    elif result == 'corrosion':
        if confidence > 0.8:
            print("‚ö†Ô∏è  –°–ò–õ–¨–ù–ê–Ø –ö–û–†–†–û–ó–ò–Ø! –¢—Ä–µ–±—É–µ—Ç—Å—è –æ—á–∏—Å—Ç–∫–∞ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏.")
        else:
            print("üü° –£–º–µ—Ä–µ–Ω–Ω–∞—è –∫–æ—Ä—Ä–æ–∑–∏—è. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥.")
    elif result == 'normal':
        print("‚úÖ –°–æ—Å—Ç–æ—è–Ω–∏–µ –≤ –Ω–æ—Ä–º–µ. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —Ä–µ–≥—É–ª—è—Ä–Ω—ã–π –æ—Å–º–æ—Ç—Ä.")
    elif result == 'uncertain':
        print("‚ùì –ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —Ä—É—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞.")
    else:
        print("‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç. –¢—Ä–µ–±—É–µ—Ç—Å—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞.")

def display_image_with_result(image, result, confidence):
    try:
        display_img = image.copy()

        text = f"{result.upper()} ({confidence:.1%})"

        if result == 'crack':
            color = (0, 0, 255)
        elif result == 'corrosion':
            color = (0, 165, 255)
        elif result == 'normal':
            color = (0, 255, 0)
        else:
            color = (128, 128, 128)

        cv2.putText(display_img, text, (10, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 1, color, 2)

        height, width = display_img.shape[:2]
        max_size = 800
        if max(height, width) > max_size:
            scale = max_size / max(height, width)
            new_width = int(width * scale)
            new_height = int(height * scale)
            display_img = cv2.resize(display_img, (new_width, new_height))

        cv2.imshow(f"–†–µ–∑—É–ª—å—Ç–∞—Ç: {result}", display_img)
        cv2.waitKey(3000)
        cv2.destroyAllWindows()

    except Exception as e:
        print(f"‚ö†Ô∏è  –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: {e}")

def analyze_single_image(classifier):
    print("\nüìÑ –ê–ù–ê–õ–ò–ó –û–î–ù–û–ì–û –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–Ø")
    print("=" * 40)

    while True:
        image_path = input("\nüìÅ –í–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é (–∏–ª–∏ '–Ω–∞–∑–∞–¥' –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞): ").strip()

        if image_path.lower() == '–Ω–∞–∑–∞–¥':
            return

        image_path = image_path.strip('"\'')

        if not os.path.exists(image_path):
            print("‚ùå –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω!")
            print(f"üí° –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—É—Ç—å: {image_path}")
            continue

        if not os.path.isfile(image_path):
            print("‚ùå –≠—Ç–æ –ø–∞–ø–∫–∞, –∞ –Ω–µ —Ñ–∞–π–ª!")
            continue

        valid_ext = ('.jpg', '.jpeg', '.png', '.bmp', '.tiff')
        if not image_path.lower().endswith(valid_ext):
            print(f"‚ùå –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: {', '.join(valid_ext)}")
            continue

        print(f"\nüîç –ê–Ω–∞–ª–∏–∑: {os.path.basename(image_path)}")
        print("-" * 40)

        result, confidence, image = classifier.predict_image(image_path)

        if result:
            print(f"\nüéØ –†–ï–ó–£–õ–¨–¢–ê–¢ –ê–ù–ê–õ–ò–ó–ê:")
            print(f"üìÅ –§–∞–π–ª: {os.path.basename(image_path)}")
            print(f"üìä –†–µ–∑—É–ª—å—Ç–∞—Ç: {classifier._get_status_emoji(result)} {result.upper()}")
            print(f"üéØ –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {confidence:.2%}")
            print(f"üìè –†–∞–∑–º–µ—Ä: {os.path.getsize(image_path) / 1024:.1f} –ö–ë")

            display_recommendations(result, confidence)

            if image is not None:
                display_image_with_result(image, result, confidence)

        input("\nüìå –ù–∞–∂–º–∏—Ç–µ Enter –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è...")

def display_statistics(results):
    if not results:
        return

    crack_count = sum(1 for r in results if r['result'] == 'crack')
    corrosion_count = sum(1 for r in results if r['result'] == 'corrosion')
    normal_count = sum(1 for r in results if r['result'] == 'normal')
    uncertain_count = sum(1 for r in results if r['result'] == 'uncertain')

    total = len(results)

    print("\nüìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê –ê–ù–ê–õ–ò–ó–ê:")
    print("=" * 40)
    print(f"üö® –¢—Ä–µ—â–∏–Ω—ã:     {crack_count:3d} ({crack_count / total * 100:.1f}%)")
    print(f"‚ö†Ô∏è  –ö–æ—Ä—Ä–æ–∑–∏—è:    {corrosion_count:3d} ({corrosion_count / total * 100:.1f}%)")
    print(f"‚úÖ –ù–æ—Ä–º–∞:       {normal_count:3d} ({normal_count / total * 100:.1f}%)")
    print(f"‚ùì –ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ: {uncertain_count:3d} ({uncertain_count / total * 100:.1f}%)")
    print(f"üìä –í—Å–µ–≥–æ:       {total:3d} (100%)")

    risk_score = (crack_count * 10 + corrosion_count * 5 + uncertain_count * 2) / total if total > 0 else 0

    print(f"\nüìà –û–¶–ï–ù–ö–ê –†–ò–°–ö–ê: {risk_score:.1f}/10")
    if risk_score > 7:
        print("üö® –í–´–°–û–ö–ò–ô –†–ò–°–ö! –¢—Ä–µ–±—É–µ—Ç—Å—è —Å—Ä–æ—á–Ω—ã–π –æ—Å–º–æ—Ç—Ä!")
    elif risk_score > 4:
        print("‚ö†Ô∏è  –°–†–ï–î–ù–ò–ô –†–ò–°–ö! –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –ø–ª–∞–Ω–æ–≤—ã–π –æ—Å–º–æ—Ç—Ä.")
    else:
        print("‚úÖ –ù–ò–ó–ö–ò–ô –†–ò–°–ö! –°–æ—Å—Ç–æ—è–Ω–∏–µ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ–µ.")

def display_detailed_results(results):
    print("\nüìã –î–ï–¢–ê–õ–¨–ù–´–ï –†–ï–ó–£–õ–¨–¢–ê–¢–´:")
    print("=" * 80)
    print(f"{'–§–∞–π–ª':<30} {'–†–µ–∑—É–ª—å—Ç–∞—Ç':<15} {'–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å':<12} {'–°—Ç–∞—Ç—É—Å':<10}")
    print("-" * 80)

    sorted_results = sorted(results, key=lambda x: x['confidence'], reverse=True)

    for result in sorted_results[:20]:
        confidence_str = f"{result['confidence']:.2%}"
        print(f"{result['file'][:30]:<30} {result['result']:<15} {confidence_str:<12} {result['status']:<10}")

    if len(sorted_results) > 20:
        print(f"... –∏ –µ—â–µ {len(sorted_results) - 20} —Ñ–∞–π–ª–æ–≤")

def save_report(results, folder_path):
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    report_file = os.path.join(folder_path, f"report_{timestamp}.txt")

    try:
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write("=" * 60 + "\n")
            f.write("–û–¢–ß–ï–¢ –ê–ù–ê–õ–ò–ó–ê –î–ï–§–ï–ö–¢–û–í\n")
            f.write("=" * 60 + "\n\n")

            f.write(f"üìÖ –î–∞—Ç–∞ –∞–Ω–∞–ª–∏–∑–∞: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"üìÅ –ü–∞–ø–∫–∞: {folder_path}\n")
            f.write(f"üìä –í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤: {len(results)}\n\n")

            crack_count = sum(1 for r in results if r['result'] == 'crack')
            corrosion_count = sum(1 for r in results if r['result'] == 'corrosion')
            normal_count = sum(1 for r in results if r['result'] == 'normal')
            uncertain_count = sum(1 for r in results if r['result'] == 'uncertain')

            f.write("–°–¢–ê–¢–ò–°–¢–ò–ö–ê:\n")
            f.write("-" * 40 + "\n")
            f.write(f"–¢—Ä–µ—â–∏–Ω—ã:     {crack_count}\n")
            f.write(f"–ö–æ—Ä—Ä–æ–∑–∏—è:    {corrosion_count}\n")
            f.write(f"–ù–æ—Ä–º–∞:       {normal_count}\n")
            f.write(f"–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ: {uncertain_count}\n\n")

            f.write("–î–ï–¢–ê–õ–¨–ù–´–ï –†–ï–ó–£–õ–¨–¢–ê–¢–´:\n")
            f.write("-" * 80 + "\n")

            for result in sorted(results, key=lambda x: x['file']):
                confidence_str = f"{result['confidence']:.2%}"
                f.write(f"{result['file']:<40} {result['result']:<15} {confidence_str}\n")

        print(f"\n‚úÖ –û—Ç—á–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {report_file}")

    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –æ—Ç—á–µ—Ç–∞: {e}")

def analyze_folder(classifier):
    print("\nüìÅ –ê–ù–ê–õ–ò–ó –ü–ê–ü–ö–ò –° –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–Ø–ú–ò")
    print("=" * 40)

    folder_path = input("\nüìÅ –í–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ: ").strip()
    folder_path = folder_path.strip('"\'')

    if not os.path.exists(folder_path):
        print("‚ùå –ü–∞–ø–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!")
        return

    if not os.path.isdir(folder_path):
        print("‚ùå –≠—Ç–æ –Ω–µ –ø–∞–ø–∫–∞!")
        return

    image_extensions = ['*.jpg', '*.jpeg', '*.png', '*.bmp', '*.tiff']
    image_files = []

    for ext in image_extensions:
        image_files.extend(glob.glob(os.path.join(folder_path, ext)))
        image_files.extend(glob.glob(os.path.join(folder_path, ext.upper())))

    image_files = list(set(image_files))
    image_files.sort()

    print(f"\nüîç –ù–∞–π–¥–µ–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {len(image_files)}")

    if not image_files:
        print("‚ùå –í –ø–∞–ø–∫–µ –Ω–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π!")
        return

    print("\nüìÑ –§–ê–ô–õ–´ –î–õ–Ø –ê–ù–ê–õ–ò–ó–ê:")
    for i, img_file in enumerate(image_files[:10], 1):
        print(f"  {i}. {os.path.basename(img_file)}")

    if len(image_files) > 10:
        print(f"  ... –∏ –µ—â–µ {len(image_files) - 10} —Ñ–∞–π–ª–æ–≤")

    confirm = input(f"\n‚ö†Ô∏è  –ù–∞—á–∞—Ç—å –∞–Ω–∞–ª–∏–∑ {len(image_files)} —Ñ–∞–π–ª–æ–≤? (y/n): ").lower()
    if confirm != 'y':
        print("‚ùå –ê–Ω–∞–ª–∏–∑ –æ—Ç–º–µ–Ω–µ–Ω")
        return

    print("\nüîç –ó–ê–ü–£–°–ö –ê–ù–ê–õ–ò–ó–ê...")
    results = classifier.predict_batch(image_files)

    if results:
        display_statistics(results)

        display_detailed_results(results)

        save_report(results, folder_path)
    else:
        print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∞–Ω–∞–ª–∏–∑–∞")

    input("\nüìå –ù–∞–∂–º–∏—Ç–µ Enter –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è...")

def clean_temp_files():
    temp_files = [
        'test_temp.jpg', 'test_image.jpg',
        'temp.jpg', 'temp.png'
    ]

    cleaned = 0
    print("\nüßπ –û–ß–ò–°–¢–ö–ê –í–†–ï–ú–ï–ù–ù–´–• –§–ê–ô–õ–û–í")
    print("=" * 40)

    for temp_file in temp_files:
        if os.path.exists(temp_file):
            try:
                os.remove(temp_file)
                print(f"üóëÔ∏è  –£–¥–∞–ª–µ–Ω: {temp_file}")
                cleaned += 1
            except Exception as e:
                print(f"‚ö†Ô∏è  –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å {temp_file}: {e}")

    reports = glob.glob("report_*.txt")
    for report in reports[:5]:
        try:
            os.remove(report)
            print(f"üóëÔ∏è  –£–¥–∞–ª–µ–Ω —Å—Ç–∞—Ä—ã–π –æ—Ç—á–µ—Ç: {report}")
            cleaned += 1
        except:
            pass

    if cleaned > 0:
        print(f"\n‚úÖ –û—á–∏—â–µ–Ω–æ —Ñ–∞–π–ª–æ–≤: {cleaned}")
    else:
        print("‚úÖ –í—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")

    input("\nüìå –ù–∞–∂–º–∏—Ç–µ Enter –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è...")

def show_model_info(classifier):
    print("\nüìä –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –ú–û–î–ï–õ–ò")
    print("=" * 50)

    if classifier.model_info:
        for key, value in classifier.model_info.items():
            if key == 'accuracy':
                print(f"üéØ {key}: {value:.2f}%")
            elif key == 'date':
                print(f"üìÖ {key}: {value}")
            elif key == 'classes':
                print(f"üè∑Ô∏è  {key}: {', '.join(value)}")
            elif key == 'data_size':
                print(f"üìä {key}: {value} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π")
            else:
                print(f"üìù {key}: {value}")
    else:
        print("‚ÑπÔ∏è  –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –º–æ–¥–µ–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞")

    print(f"\nüíª –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:")
    print(f"  –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {classifier.device}")
    print(f"  –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Å–æ–≤: {len(classifier.class_names)}")
    print(f"  –†–∞–∑–º–µ—Ä –≤—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: 256x256 –ø–∏–∫—Å–µ–ª–µ–π")

    input("\nüìå –ù–∞–∂–º–∏—Ç–µ Enter –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è...")

def check_and_create_test_data():
    print("\nüîç –ü–†–û–í–ï–†–ö–ê –î–ê–ù–ù–´–•")
    print("=" * 40)

    categories = ['crack', 'corrosion', 'normal']
    has_data = False

    for category in categories:
        if os.path.exists(category) and len(os.listdir(category)) > 0:
            has_data = True
            images = [f for f in os.listdir(category)
                      if f.lower().endswith(('.jpg', '.jpeg', '.png'))]
            print(f"‚úÖ {category}: {len(images)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π")
        else:
            print(f"‚ùå {category}: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö")

    if not has_data:
        print("\n‚ö†Ô∏è  –ù–ï–¢ –¢–†–ï–ù–ò–†–û–í–û–ß–ù–´–• –î–ê–ù–ù–´–•!")
        choice = input("–°–æ–∑–¥–∞—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏? (y/n): ").lower()
        if choice == 'y':
            create_test_data()

    return has_data

def create_test_data():
    print("\nüß™ –°–û–ó–î–ê–ù–ò–ï –¢–ï–°–¢–û–í–´–• –î–ê–ù–ù–´–•")
    print("=" * 40)

    categories = ['crack', 'corrosion', 'normal']

    for category in categories:
        os.makedirs(category, exist_ok=True)

        for i in range(5):
            if category == 'crack':
                img = np.random.randint(100, 150, (256, 256, 3), dtype=np.uint8)
                cv2.line(img, (50, 50), (200, 200), (50, 50, 50), 3)
                cv2.line(img, (30, 200), (220, 30), (50, 50, 50), 2)
            elif category == 'corrosion':
                img = np.random.randint(150, 200, (256, 256, 3), dtype=np.uint8)
                for _ in range(10):
                    x = np.random.randint(50, 200)
                    y = np.random.randint(50, 200)
                    radius = np.random.randint(5, 20)
                    cv2.circle(img, (x, y), radius, (100, 100, 100), -1)
            else:
                img = np.random.randint(200, 255, (256, 256, 3), dtype=np.uint8)

            filename = os.path.join(category, f"test_{i + 1}.jpg")
            cv2.imwrite(filename, img)
            print(f"‚úÖ –°–æ–∑–¥–∞–Ω–æ: {filename}")

    print("\nüéâ –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ —Å–æ–∑–¥–∞–Ω—ã!")
    print("üí° –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å —Ä–µ–∞–ª—å–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ —ç—Ç–∏ –ø–∞–ø–∫–∏")

def main():
    print("üéØ –ü–†–û–î–í–ò–ù–£–¢–ê–Ø –°–ò–°–¢–ï–ú–ê –ê–ù–ê–õ–ò–ó–ê –î–ï–§–ï–ö–¢–û–í")
    print("=" * 60)

    check_and_create_test_data()

    model_manager = ModelManager()

    selected_model = None
    classifier = None

    while True:
        if not selected_model:
            print("\nüîç –í–´–ë–û–† –ú–û–î–ï–õ–ò –î–õ–Ø –ê–ù–ê–õ–ò–ó–ê")
            selected_model = model_manager.select_model_interactive()

            if not selected_model:
                print("\nüí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:")
                print("1. –°–Ω–∞—á–∞–ª–∞ –æ–±—É—á–∏—Ç–µ –º–æ–¥–µ–ª—å —Å –ø–æ–º–æ—â—å—é —Å–∫—Ä–∏–ø—Ç–∞ –æ–±—É—á–µ–Ω–∏—è")
                print("2. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤ –ø–∞–ø–∫–µ 'models/' –µ—Å—Ç—å —Ñ–∞–π–ª—ã .pth")
                print("3. –ú–æ–¥–µ–ª–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ –æ–±—É—á–µ–Ω–∏–∏")

                choice = input("\n–•–æ—Ç–∏—Ç–µ —Å–æ–∑–¥–∞—Ç—å —Ç–µ—Å—Ç–æ–≤—É—é –º–æ–¥–µ–ª—å? (y/n): ").lower()
                if choice == 'y':
                    print("\n‚ö†Ô∏è  –î–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –º–æ–¥–µ–ª–∏ –Ω—É–∂–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å —Å–∫—Ä–∏–ø—Ç –æ–±—É—á–µ–Ω–∏—è")
                    print("üí° –°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª '–æ–±—É—á–µ–Ω–∏–µ.py' —Å –∫–æ–¥–æ–º –æ–±—É—á–µ–Ω–∏—è")
                break

            try:
                print(f"\n‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏...")
                classifier = AdvancedDefectClassifier(selected_model['path'])
            except Exception as e:
                print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥–µ–ª–∏: {e}")
                selected_model = None
                continue

        print("\n" + "=" * 60)
        print(f"–¢–ï–ö–£–©–ê–Ø –ú–û–î–ï–õ–¨: {selected_model['name']}")
        if selected_model['metadata'] and 'accuracy' in selected_model['metadata']:
            print(f"–¢–û–ß–ù–û–°–¢–¨: {selected_model['metadata']['accuracy']:.2f}%")
        print("=" * 60)

        print("\nüìã –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ:")
        print("1. üìÑ –ê–Ω–∞–ª–∏–∑ –æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
        print("2. üìÅ –ê–Ω–∞–ª–∏–∑ –ø–∞–ø–∫–∏ —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏")
        print("3. üìä –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –º–æ–¥–µ–ª–∏")
        print("4. üîÑ –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é –º–æ–¥–µ–ª—å")
        print("5. üßπ –û—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤")
        print("6. üß™ –°–æ–∑–¥–∞—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ")
        print("7. üö™ –í—ã—Ö–æ–¥")

        choice = input("\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ (1-7): ").strip()

        if choice == '1':
            if classifier:
                analyze_single_image(classifier)
            else:
                print("‚ùå –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω!")

        elif choice == '2':
            if classifier:
                analyze_folder(classifier)
            else:
                print("‚ùå –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω!")

        elif choice == '3':
            if classifier:
                show_model_info(classifier)
            else:
                print("‚ùå –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω!")

        elif choice == '4':
            new_model = model_manager.select_model_interactive()
            if new_model and new_model['path'] != selected_model['path']:
                selected_model = new_model
                try:
                    print(f"\n‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ –Ω–æ–≤–æ–π –º–æ–¥–µ–ª–∏...")
                    classifier = AdvancedDefectClassifier(selected_model['path'])
                    print(f"‚úÖ –ú–æ–¥–µ–ª—å —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞!")
                except Exception as e:
                    print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥–µ–ª–∏: {e}")
                    print("‚ö†Ô∏è  –í–æ–∑–≤—Ä–∞—Ç –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –º–æ–¥–µ–ª–∏...")

        elif choice == '5':
            clean_temp_files()

        elif choice == '6':
            create_test_data()

        elif choice == '7':
            print("\nüëã –î–æ —Å–≤–∏–¥–∞–Ω–∏—è!")
            break

        else:
            print("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä!")

def install_requirements():
    print("\nüì¶ –£–°–¢–ê–ù–û–í–ö–ê –ë–ò–ë–õ–ò–û–¢–ï–ö")
    print("=" * 40)

    import subprocess
    import sys

    requirements = [
        'torch',
        'torchvision',
        'opencv-python',
        'Pillow',
        'numpy'
    ]

    for package in requirements:
        print(f"–£—Å—Ç–∞–Ω–æ–≤–∫–∞ {package}...")
        try:
            subprocess.check_call([sys.executable, '-m', 'pip', 'install', package, '--quiet'])
            print(f"‚úÖ {package} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        except:
            print(f"‚ö†Ô∏è  –ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å {package}")

    print("\nüéâ –í—Å–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã!")

if __name__ == "__main__":
    try:
        import torch
        import torchvision

        print(f"‚úÖ PyTorch {torch.__version__} –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ")
    except ImportError:
        print("‚ùå PyTorch –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")
        install = input("–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏? (y/n): ").lower()
        if install == 'y':
            install_requirements()
        else:
            print("üí° –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –≤—Ä—É—á–Ω—É—é:")
            print("pip install torch torchvision opencv-python pillow numpy")
            exit()

    main()
